#include <vector>
#include <algorithm>


template<typename I1, typename I2>
I2 myremove(I1 s1, I1 e1, I2 s2, I2 e2) {
    std::vector<bool> removeMap(std::distance(s2, e2), false);
    for (I1 it = s1; it != e1; ++it) if (*it < int(removeMap.size())) removeMap[*it] = true;

    int i = 0;
    return std::remove_if(s2, e2, [&]<typename T>(const T &x) {
        return removeMap[i++];
    });
}


/* Примите моё решение.
 *
 * Пришел reject: Неэффективное решение
 *
 * Почему нужно принять моё решение?
 *
 * Основной аргумент: на всех тестах мое решение работает в два раза быстрее, чем решение тех, у кого оно "принято".
 *
 * Второстепенный аргумент: мое решение оптимально по алгоритмической сложности
 *
 * Объясните мне, почему мое решение "неэффективное"
 *
 *
 *
 *
 * Развернутое объяснение эффективности (мне же делать нечего — объясняю взрослым людям эффективность решения, которое
 *                                       работает в два раза быстрее других решений)
 * Пусть:
 * n = std::distance(s1, e1);
 * m = std::distance(s2, e2).
 *
 * Моё решение:
 * Память: O(m)
 * Алгоритм: O(n+m)
 *
 * Куда оптимальнее по числу операций?
 *
 * У товарищей, у которых решение "принято" есть другой алгоритм с использованием std::set, оно:
 * Память: O(n)
 * Алгоритм: O((n+m)log(n))
 *
 * И это лучше по-вашему?
 *
 * Это решение лучше только если удаляется очень мало элементов. В таком случае действительно создать условный set
 * за O(n*log(n)) вместо vector за O(m) съест меньше операций и памяти.
 * И дальнейшие обращения к set за O(log n) можно считать за O(1) если n МАЛО и ФИКСИРОВАНО. В таком предположении — да.
 * В условии этого предположения нет... Поэтому — нет.
 *
 * Предположим обратное. Массив данных МАЛ и ФИКСИРОВАН, но обращений на удаление — много.
 * В этом случае мое решение превращается по памяти в O(1), по операциям O(n). В этом случае оно оптимальнее другого.
 * Но опять же в УСЛОВИИ комментариев по этому поводу НЕТ.
 *
 * В общем случае мое решение оптимально.
 * На всех тестах оно работает в два раза быстрее.
 * Объясните мне неэффективность.
 */
